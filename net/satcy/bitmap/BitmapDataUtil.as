package net.satcy.bitmap{	import flash.display.*;	import flash.geom.*;	import flash.filters.*;	public class BitmapDataUtil{		public static var uoffset:Number = -19;		public static var urange:Number = 21;		public static var voffset:Number = 21;		public static var vrange:Number = 31;		        public static function thresholdFilter(s:BitmapData, _threshold:uint):BitmapData {			var dst:BitmapData = s.clone();            var d:BitmapData = new BitmapData(dst.width, dst.height);            var r:Rectangle = new Rectangle(0, 0, dst.width, dst.height);            d.fillRect(r, 0xFF000000);            d.threshold(dst, r, new Point(0, 0), ">=", _threshold, 0xFFFFFFFF, 255, false);			dst.dispose();            return d;        }		public static function skinFilter(bmp:BitmapData):BitmapData{			var bound = new Rectangle(0, 0, bmp.width, bmp.height);			/*			var rgb2yuv = new ColorMatrixFilter();			var yuv2seg = new ColorMatrixFilter();			rgb2yuv.matrix = [0.299, 0.587, 0.114, 0, 0, -0.169, -0.331, 0.5, 0, 128, 0.5, -0.419, -0.081, 0, 128, 0, 0, 0, 1, 0];			yuv2seg.matrix = [0, 0, 0, 0, 0, 0, 0.04, 0, 0, 123.5, 0, 0, 0.04, 0, 122.3, 0, 0, 0, 1, 0];			var src:BitmapData = bmp.clone();			var dst:BitmapData = new BitmapData(bmp.width, bmp.height);			src.applyFilter(src, bound, new Point(0,0), rgb2yuv);			src.applyFilter(src, bound, new Point(0,0), yuv2seg);			//dst.fillRect(bound, 0xFF000000);			src.threshold(src, bound, new Point(0,0), "==", 0x008080, 0xFFFFFFFF, 0xFFFFFF, false);			src.threshold(src, bound, new Point(0,0), "!=", 0xFFFFFF, 0xFF000000, 0xFFFFFF, false);			*/			//src = null;			var src:BitmapData = bmp.clone();			var skin2seg = new flash.filters.ColorMatrixFilter();			//skin2seg.matrix = createSkinMatrix(-15, 25, 20, 25);			skin2seg.matrix = createSkinMatrix(uoffset, uoffset, voffset, vrange);			var SEGMENT_COLOR:Number = 0x008080;			var SEGMENT_MASK:Number = 0x00C0C0;			src.applyFilter(src, bound, new Point(0,0), skin2seg);			src.threshold(src, bound, new Point(0,0), "!=", SEGMENT_COLOR, 0xFF000000, SEGMENT_MASK, false);			src.threshold(src, bound, new Point(0,0), "==", SEGMENT_COLOR, 0xFFFFFFFF, SEGMENT_MASK, false);			return src;					}				private static function createSkinMatrix(__uoffset, __urange, __voffset, __vrange):Array {			var u = 64 / __urange;			var v = 64 / __vrange;			var a:Array = [];			a.push(0, 0, 0, 0, 0);			a.push(-0.169 * u, -0.331 * u, +0.500 * u, 0, (__urange / 2 - __uoffset) * u + 128);			a.push(+0.500 * v, -0.419 * v, -0.081 * v, 0, (__vrange / 2 - __voffset) * v + 128);			a.push(0, 0, 0, 1, 0);			return a;		}		public static function subtract(bmd1:BitmapData, bmd2:BitmapData):BitmapData{			var bmd:BitmapData = bmd1.clone();			bmd.draw(bmd2, new Matrix(), new ColorTransform(), "subtract", new Rectangle(0, 0, bmd1.width, bmd1.height), false);			return bmd;		}		        public static function grayscaleFilter(s:BitmapData):BitmapData {            var d:BitmapData = new BitmapData(s.width, s.height);            d.applyFilter(s, new Rectangle(0, 0, s.width, s.height), new Point(0, 0),                          new ColorMatrixFilter([1/3, 1/3, 1/3, 0, 0,                                                 1/3, 1/3, 1/3, 0, 0,                                                 1/3, 1/3, 1/3, 0, 0,                                                 0, 0, 0, 255, 0]));            return d;        }		///Edge		public static function laplacianFilter(s:BitmapData):BitmapData {            var d:BitmapData = new BitmapData(s.width, s.height);            var l:Array = [-1, -1, -1,                           -1, +8, -1,                           -1, -1, -1];            d.applyFilter(s, new Rectangle(0, 0, s.width, s.height), new Point(0, 0),                          new ConvolutionFilter(3, 3, l));            return d;        }				public static function medianSmoothFilter(s:BitmapData):BitmapData {            var d:BitmapData = new BitmapData(s.width, s.height);            var a:Array = new Array(9);            for (var x:int = 0; x < s.width; x++) {                for (var y:int = 0; y < s.height; y++) {                    a[0] = s.getPixel(x - 1, y - 1) & 255;                    a[1] = s.getPixel(x - 1, y) & 255;                    a[2] = s.getPixel(x - 1, y + 1) & 255;                    a[3] = s.getPixel(x, y - 1) & 255;                    a[4] = s.getPixel(x, y) & 255;                    a[5] = s.getPixel(x, y + 1) & 255;                    a[6] = s.getPixel(x + 1, y - 1) & 255;                    a[7] = s.getPixel(x + 1, y) & 255;                    a[8] = s.getPixel(x + 1, y + 1) & 255;                    a.sort(Array.NUMERIC); // ソートして                    var c:int = a[4]; // 真ん中を取る                    d.setPixel(x, y, (c << 16) | (c << 8) | c); // 中央値による色の設定                }            }            return d;        }		/** 膨張         * @param dst デスティネーション         * @param src ソース         */        public static function Dilate(dst:BitmapData, src:BitmapData):void {            for (var x:int = 0; x < src.width; x++) {                for (var y:int = 0; y < src.height; y++) {                    var max:int = 0, c:int;                    c = src.getPixel(x - 1, y) & 255;                    max = c > max ? c : max;                    c = src.getPixel(x, y - 1) & 255;                    max = c > max ? c : max;                    c = src.getPixel(x, y) & 255;                    max = c > max ? c : max;                    c = src.getPixel(x, y + 1) & 255;                    max = c > max ? c : max;                    c = src.getPixel(x + 1, y) & 255;                    max = c > max ? c : max;                    dst.setPixel(x, y, (max << 16) | (max << 8) | max);                }            }        }		/** 収縮         * @param dst デスティネーション         * @param src ソース         */        public static function Erode(dst:BitmapData, src:BitmapData):void {            for (var x:int = 0; x < src.width; x++) {                for (var y:int = 0; y < src.height; y++) {                    var min:int = 255, c:int;                    c = src.getPixel(x - 1, y) & 255;                    min = c < min ? c : min;                    c = src.getPixel(x, y - 1) & 255;                    min = c < min ? c : min;                    c = src.getPixel(x, y) & 255;                    min = c < min ? c : min;                    c = src.getPixel(x, y + 1) & 255;                    min = c < min ? c : min;                    c = src.getPixel(x + 1, y) & 255;                    min = c < min ? c : min;                    dst.setPixel(x, y, (min << 16) | (min << 8) | min);                }            }        }		/** 切断         * @param dst デスティネーション         * @param src ソース         */        public static function Open(dst:BitmapData, src:BitmapData):void {            var tmp:BitmapData = new BitmapData(src.width, src.height);            Erode(tmp, src);            Dilate(dst, tmp);        }		/** 接続         * @param dst デスティネーション         * @param src ソース         */        public static function Close(dst:BitmapData, src:BitmapData):void {            var tmp:BitmapData = new BitmapData(src.width, src.height);            Dilate(tmp, src);            Erode(dst, tmp);        }				public static function labeling(src:BitmapData):BitmapData {			var dst:BitmapData = src.clone(); // ソースの複製を作る			var temp:BitmapData = new BitmapData( dst.width, 1, false, 0x000000 );			var lno:int = 0;			var zero:Point = new Point();			var rect:Rectangle = dst.getColorBoundsRect( 0xffffff, 0xffffff, true );			var area:Rectangle = new Rectangle( 0, 0, dst.width, 1 );			while ( !rect.isEmpty() ){				area.y = rect.top;				temp.copyPixels( dst, area, zero );				rect = temp.getColorBoundsRect( 0xffffff, 0xffffff, true );				dst.floodFill( rect.x, area.y, ++lno );				rect = dst.getColorBoundsRect( 0xffffff, 0xffffff, true );						}			return dst;		}		/** ラベル値による画像の抜き出し		 * @param lbd ラベリングデータ		 * @param lno ラベル番号		 * @return 指定のラベル番号だけ抽出したイメージ		 */		public static function extract(lbd:BitmapData, lno:int):BitmapData {			var dst:BitmapData = new BitmapData(lbd.width, lbd.height, false, 0x000000);			dst.threshold(dst, dst.rect, new Point(0,0), "==", lno, 0xFFFFFF);			return dst;		}	}	}