package net.satcy.triangulate{	import __AS3__.vec.Vector;		import flash.geom.Point;	public class Triangulate {		/*		    Return TRUE if a point (xp,yp) is inside the circumcircle made up		    of the points (x1,y1), (x2,y2), (x3,y3)		    The circumcircle centre is returned in (xc,yc) and the radius r		    NOTE: A point on the edge is inside the circumcircle		*/		private static const EPSILON:Number = 9.999999747378752E-5;		private static function circumCircle(p:Point, t:Triangle, circle:Circle):Boolean {			var m1:Number,m2:Number,mx1:Number,mx2:Number,my1:Number,my2:Number;			var dx:Number,dy:Number,rsqr:Number,drsqr:Number;			/* Check for coincident points */			if (Math.abs(t.p1.y-t.p2.y)<EPSILON && Math.abs(t.p2.y-t.p3.y)<EPSILON) {				trace("CircumCircle: Points are coincident.");				return false;			}			if (Math.abs(t.p2.y-t.p1.y)<EPSILON) {				m2 = - (t.p3.x-t.p2.x) / (t.p3.y-t.p2.y);				mx2 = (t.p2.x + t.p3.x) / 2.0;				my2 = (t.p2.y + t.p3.y) / 2.0;				circle.x = (t.p2.x + t.p1.x) / 2.0;				circle.y = m2 * (circle.x - mx2) + my2;			} else if ( Math.abs(t.p3.y-t.p2.y) < EPSILON ) {				m1 = - (t.p2.x-t.p1.x) / (t.p2.y-t.p1.y);				mx1 = (t.p1.x + t.p2.x) / 2.0;				my1 = (t.p1.y + t.p2.y) / 2.0;				circle.x = (t.p3.x + t.p2.x) / 2.0;				circle.y = m1 * (circle.x - mx1) + my1;			} else {				m1 = - (t.p2.x-t.p1.x) / (t.p2.y-t.p1.y);				m2 = - (t.p3.x-t.p2.x) / (t.p3.y-t.p2.y);				mx1 = (t.p1.x + t.p2.x) / 2.0;				mx2 = (t.p2.x + t.p3.x) / 2.0;				my1 = (t.p1.y + t.p2.y) / 2.0;				my2 = (t.p2.y + t.p3.y) / 2.0;				circle.x = (m1 * mx1 - m2 * mx2 + my2 - my1) / (m1 - m2);				circle.y = m1 * (circle.x - mx1) + my1;			}			dx=t.p2.x-circle.x;			dy=t.p2.y-circle.y;			rsqr=dx*dx+dy*dy;			circle.z=Math.sqrt(rsqr);			dx=p.x-circle.x;			dy=p.y-circle.y;			drsqr=dx*dx+dy*dy;			return drsqr <= rsqr;		}		/*		    Triangulation subroutine		    Takes as input vertices (Point3fs) in Vector pxyz		    Returned is a list of triangular faces in the Vector v 		    These triangles are arranged in a consistent clockwise order.		*/		public static function triangulate( pxyz:Array ):Array {			// sort vertex array in increasing x values			//Collections.sort(pxyz, new XComparator());			pxyz.sortOn("x", Array.NUMERIC);			/*						      Find the maximum and minimum vertex bounds.						      This is to allow calculation of the bounding triangle			*/			var xmin:Number=(pxyz[0] as Point).x;			var ymin:Number=(pxyz[0] as Point).y;			var xmax:Number=xmin;			var ymax:Number=ymin;			var i:int,l:int;			var p:Point;			l=pxyz.length;			for (i=0; i<l; i++) {				p=(pxyz[i] as Point);				if (p.x<xmin) {					xmin=p.x;				}				if (p.x>xmax) {					xmax=p.x;				}				if (p.y<ymin) {					ymin=p.y;				}				if (p.y>ymax) {					ymax=p.y;				}			}			var dx:Number=xmax-xmin;			var dy:Number=ymax-ymin;			var dmax:Number = (dx > dy) ? dx : dy;			var xmid:Number = (xmax + xmin) / 2.0;			var ymid:Number = (ymax + ymin) / 2.0;						//var v:Vector.<Triangle> = new Vector.<Triangle>();// for the Triangles			var v:Array = [];			var complete:Array = [];// for complete Triangles			/*			      Set up the supertriangle			      This is a triangle which encompasses all the sample points.			      The supertriangle coordinates are added to the end of the			      vertex list. The supertriangle is the first triangle in			      the triangle list.			*/			var superTriangle:Triangle = new Triangle();			superTriangle.p1=new Point(xmid-2.0*dmax,ymid-dmax);			superTriangle.p2=new Point(xmid,ymid+2.0*dmax);			superTriangle.p3=new Point(xmid+2.0*dmax,ymid-dmax);			v.push(superTriangle);			/*			      Include each point one at a time into the existing mesh			*/			var edges:Array;			var j:int;			var t:Triangle;			var circle:Circle = new Circle();			l=pxyz.length;			for (i=0; i<l; i++) {				p=(pxyz[i] as Point);				edges=[];				/*				        Set up the edge buffer.				        If the point (xp,yp) lies inside the circumcircle then the				        three edges of that triangle are added to the edge buffer				        and that triangle is removed.				*/				for ( j=v.length-1; j>=0; j-- ) {					t=v[j];					if (complete.indexOf(t)!=-1) {						continue;					}					var inside:Boolean=circumCircle(p,t,circle);					if (circle.x+circle.z<p.x) {						complete.push(t);					}					if (inside) {						edges.push(new Edge(t.p1, t.p2));						edges.push(new Edge(t.p2, t.p3));						edges.push(new Edge(t.p3, t.p1));						v.splice(j, 1);					}				}				/*				        Tag multiple edges				        Note: if all triangles are specified anticlockwise then all				        interior edges are opposite pointing in direction.				*/				for ( j=0; j<edges.length-1; j++ ) {					var e1:Edge=edges[j];					for (var k:int=j+1; k<edges.length; k++) {						var e2:Edge=edges[k];						if (e1.p1==e2.p2 && e1.p2==e2.p1) {							e1.p1=null;							e1.p2=null;							e2.p1=null;							e2.p2=null;						}						/* Shouldn't need the following, see note above */						if (e1.p1==e2.p1 && e1.p2==e2.p2) {							e1.p1=null;							e1.p2=null;							e2.p1=null;							e2.p2=null;						}											}				}				/*				        Form new triangles for the current point				        Skipping over any tagged edges.				        All edges are arranged in clockwise order.				*/								for ( j=0; j<edges.length; j++ ) {					var e:Edge=edges[j];					if (e.p1==null || e.p2==null) {						continue;					}					v.push(new Triangle(e.p1, e.p2, p));				}			}			/*			      Remove triangles with supertriangle vertices			*/			for ( i = v.length-1; i >= 0; i-- ) {				t=v[i];				if (t.sharesVertex(superTriangle)) {					v.splice(i, 1);				}			}			//trace(v);			//trace("--------");			return v;		}	}}